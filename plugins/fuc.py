# Placeholder

def recv_long(conn: socket.socket) -> bytes:
    msg = conn.recv(4096)
    conn.setblocking(False)
    while True:
        try:
            data = conn.recv(4096)
        except socket.error as e:
            # if e.errno == 10035:  # Resource temporarily unavailable
            #     continue
            # else:
            break
        if not data:
            break
        msg += data
    conn.setblocking(True)
    return msg




def get_sig(n1, n2, g_a, g_b, private_key):
    data_to_sign = f"{n1},{n2},{g_a},{g_b}"
    signature = private_key.sign(
        data_to_sign.encode(),
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    return signature




def load_certificate_file(file_name):
    try:
        with open(file_name, 'r') as file:
            certificate = file.read()
        return certificate
    except FileNotFoundError:
        print(f"文件 {file_name} 未找到")
        return None
    except IOError:
        print("文件读取错误")
        return None




def get_user(email: str) -> Optional[User]:
    """Get a user's info by email

    Args:
        email (str): The email of the user

    Returns:
        Optional[User]: The user object if found, None otherwise
    """
    with sqlite3.connect(path) as db_conn:
        cursor = db_conn.execute(
            f'''
            SELECT *
            FROM USER_INFO
            WHERE email = "{email}"
            '''
        )
        all = cursor.fetchall()
    if len(all) == 0:
        return None
    return User(*all[0])




    def __init__(self, email: Optional[str] = None, pwdhash: Optional[str] = None, salt: Optional[str] = None):
        """User object

        Args:
            email (Optional[str], optional): User's email. Defaults to None.
            pwdhash (Optional[str], optional): Hashcode of the user's password. Defaults to None.
            salt (Optional[str], optional): Salt of the hashcode. Defaults to None.
        """
        self.email = email
        self.pwdhash = pwdhash
        self.salt = salt


class Group:


def verify_certificate(cert, ca_public_key):
    try:
        # 用CA的公钥验证证书
        ca_public_key.verify(
            cert.signature,
            cert.tbs_certificate_bytes,
            padding.PKCS1v15(),
            cert.signature_hash_algorithm,
        )
        return True
    except Exception as e:
        print(f"证书验证失败: {e}")
        return False




    def __init__(self, email: Optional[str] = None, pwdhash: Optional[str] = None, salt: Optional[str] = None):
        """User object

        Args:
            email (Optional[str], optional): User's email. Defaults to None.
            pwdhash (Optional[str], optional): Hashcode of the user's password. Defaults to None.
            salt (Optional[str], optional): Salt of the hashcode. Defaults to None.
        """
        self.email = email
        self.pwdhash = pwdhash
        self.salt = salt


class Group:


def get_sig(n1, n2, g_a, g_b, private_key):
    data_to_sign = f"{n1},{n2},{g_a},{g_b}"
    signature = private_key.sign(
        data_to_sign.encode(),
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    return signature




    def recv(self) -> bytes:
        try:
            cipher_msg = self.sock.recv(4096)
        except:
            self.status = ConnStatus.Closed
            return b''
        self.sock.setblocking(False)
        while True:
            try:
                data = self.sock.recv(4096)
            except socket.error as e:
                # if e.errno == 10035:  # Resource temporarily unavailable
                #     continue
                # else:
                break
            if not data:
                break
            cipher_msg += data
        self.sock.setblocking(True)
        iv = cipher_msg[:16]
        aes = Crypto.Cipher.AES.new(self.key, Crypto.Cipher.AES.MODE_CFB, iv)
        plain_msg = aes.decrypt(cipher_msg[16:])
        return plain_msg
    


def init(db_path: str = path) -> None:
    """Initialize the sqlite database"""
    path = db_path
    if os.path.exists(path):
        with sqlite3.connect(path) as db_conn:
            db_conn.execute('DELETE FROM AUTHCODE_INFO;')
        return
    with sqlite3.connect(path) as db_conn:
        db_conn.execute(
            '''
            CREATE TABLE USER_INFO (
                email TEXT PRIMARY KEY,
                pwdhash TEXT NOT NULL,
                salt TEXT NOT NULL
            );
            '''
        )
        db_conn.execute(
            '''
            CREATE UNIQUE INDEX USER_email ON USER_INFO (email);
            '''
        )
        db_conn.execute(
            '''
            CREATE TABLE GROUP_INFO (
                id TEXT NOT NULL,
                member TEXT NOT NULL,
                PRIMARY KEY (id, member),
                FOREIGN KEY (member) REFERENCES USER_INFO (email) ON DELETE CASCADE
            );
            '''
        )
        db_conn.execute(
            '''
            CREATE INDEX GROUP_id ON GROUP_INFO (member);
            '''
        )
        db_conn.execute(
            '''
            CREATE TABLE AUTHCODE_INFO (
                email TEXT PRIMARY KEY,
                authcode TEXT NOT NULL,
                timestamp INTEGER NOT NULL
            );
            '''
        )



